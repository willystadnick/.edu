COMUNICAÇÃO NOS SISTEMAS DISTRIBUÍDOS

Em um sistema distribuído e sistema monoprocessador é forma de implementar a comunicação entre processos e totalmente diferente. Todos os Sistemas Operacionais Distribuídos necessitam de comunicação entre si. Deste os modelos mais simples como um semáforo e os mais complexos. Senão seriam apenas vários computadores isolados em ilhas.

PROTOCOLOS EM CAMADAS

Os Protocolos contém informações que tornam possível a compatibilidade em vários aspectos. Portanto pode-se definir protocolos, como um idioma para comunicação nos sistemas distribuídos. 

O Nível Físico

O nível físico trata da organização da transmissão dos 0s e 1s. Controlando a quantidade de volts necessários a representar cada um dos dois níveis lógicos, a que freqüência eles devem ser transmitidos, se a transmissão de dados pode ser feita nos dois sentidos simultaneamente. Para que, quando uma maquina enviar um bit 0 , as outras recebam um bit 0.

O nível do Enlace de Dados

O enlace de dados é responsável pela implementação  de mecanismos que detectem e corrijam erros nas redes. Para tanto, os bits são agrupados em unidades, denominados quadros. A função deste nível é verificar se os quadros estão sendo corretamente recebidos.

O nível da rede

A principal tarefa do nível de rede é escolher o melhor caminho também chamado de roteamento.

O nível de transporte

A função do nível de transporte é fornecer o serviço recuperação de erros. A idéia é que o nível da sessão possa enviar uma mensagem para o de transporte, com a expectativa de que ela seja entregue sem nenhuma perda.
Ao receber uma mensagem do nível de sessão, o nível de transporte abre a mensagem em pedaços, pequenos o suficiente para cada um conter um único pacote, atribuindo a cada de tais pedaços um número seqüencial. Ao término deste trabalho, ele transmite todos eles. A discussão no cabeçalho do nível de transporte diz respeito aos pacotes que foram enviados, aos que foram recebidos, quanto de espaço há no receptor para aceitá-los, além de outros assuntos similares.

O nível de sessão

Ele fornece uma metodologia para controle de diálogo, de forma a estabelecer qual das partes está falando, além de fornecer também facilidades para sincronização. 

O nível de apresentação

O nível de apresentação cuida do significado dos bits enviados por um transmissor. No nível de apresentação é possível definirem-se registros contendo campos para recebimentos da informação estruturada, e então fazer com que o transmissor informe ao receptor que a mensagem é composta por registros em determinados formatos. 

O nível de aplicação

O nível de aplicação é, na verdade, composto por um conjunto de diversos protocolos voltados para diferentes atividades, como correio eletrônico, transferência de arquivos, e conexão de terminais remotos a computadores através de uma rede.

O modelo cliente-servidor

Os protocolos em camadas, que seguem a linha do OSI, parecem uma forma bastante elegante e conveniente de se organizar um sistema distribuído. Neste modelo, um transmissor estabelece uma conexão com um receptor (um pipe de bits), e bombeia os bits dentro deste pipe. Porém a existência de muitos cabeçalhos cria uma dose considerável de overhead no sistema.

Clientes e servidores

A idéia por trás deste é a de estruturar o sistema operacional como um grupo de processos cooperantes, denominados servidores, que oferecem serviços a processos usuários (solicitam serviços através de mensagens). As máquinas servidoras normalmente rodam o mesmo microkernel, onde tanto os clientes quanto os servidores roam como processos usuários, conforme visto anteriormente. Uma máquina pode rodar um único processo, vários clientes, vários servidores, ou uma mistura dos dois.

OPERAÇÃO BÁSICA DA CHAMADA REMOTA A PROCEDIMENTO

Para compreender o funcionamento da chamada remota a procedimento é importante entender como funciona a chamada a procedimento em uma máquina convencional. Para fazer a chamada o procedimento chamador coloca os parâmetros na pilha em ordem, após ter terminado a execução, armazena o valor de retorno em um registrador, remove seu endereço de retorno e transfere o controle de volta a quem chamou, fazendo com que a pilha retorne ao seu estado original. Os parâmetros podem ser chamados por valor ou por referência. 
Um parâmetro chamado por valor é simplesmente copiado da pilha. Para o procedimento chamado, este é igual a uma variável local inicializada, se ele for modificado durante a execução deste procedimento, seu valor original no procedimento que chamou não será afetado.
Um parâmetro passado por referência é um ponteiro, ou seja, o que vai realmente para a pilha é o endereço da variável, e não o valor desta. Se o procedimento chamado alterar o valor deste parâmetro, o modificará também no procedimento chamador.
Existe ainda um outro mecanismo para passagem de parâmetros, denominado chamada por cópia/restauração. Consiste em copiar uma variável para a pilha pelo procedimento chamador, e então copiá-la de volta após a execução da chamada, substituindo o valor original.
A idéia por trás da chamada remota a procedimento é fazer com que esta se pareça tanto quanto possível com uma chamada local, ou seja, o procedimento chamador não deve se preocupar com o fato do procedimento chamado estar ou não rodando em uma máquina diferente, e vice-versa. 

PASSAGEM DE PARÂMETROS

A função do stub de cliente é a de tomar seus parâmetros, empacotá-los em uma mensagem e enviá-los ao stub do servidor. O empacotamento dos parâmetros em uma mensagem é chamado de ordenação de parâmetros.
O stub do cliente forma uma mensagem com os parâmetros e coloca na mensagem o nome ou o número do procedimento a ser chamado. Quando a mensagem chega ao servidor, o stub a examina para saber qual o procedimento a que ela se refere, e, então, faz a chamada apropriada.
Quando o servidor termina a execução, seu stub retoma o controle, empacotando o resultado em uma mensagem. Esta é enviada para o stub do cliente, que a desempacota e retorna o valor obtido ao procedimento-cliente.
Para evitar erros de interpretação  ocasionado por máquinas diferentes, os procedimentos são enviados com uma campo a mais para identificação dos parâmetros. Com isso torna-se possível realizar qualquer tipo de conversão
O maior problema ligado às chamadas remotas a procedimentos é a passagem de ponteiros, pois estes só têm significado no espaço de endereçamento do processo no qual está sendo usado.
Uma das soluções seria proibir a passagem de ponteiros e de parâmetros por referência. As modificações que o servidor faz usando o ponteiro afetam diretamente o buffer da mensagem dentro do stub do servidor.

LIGAÇÃO DINÂMICA

É a maneira como o cliente localiza o servidor. Sempre que uma interface é registrada ou tem seu registro cancelado, será necessária uma quantidade substancial de mensagens, de maneira a manter todos os ligadores sincronizados e atualizados, gerando mais overhead.

SEMÂNTICA DA CHAMADA REMOTA A PROCEDIMENTO EM PRESENÇA DE FALHAS

O objetivo da chamada remota é manter escondido do usuário os procedimentos relativos à comunicação remota, fazendo com que as chamadas pareçam invocar procedimentos locais. Enquanto o cliente e o servidor estiverem funcionando perfeitamente, a chamada remota a procedimento é admirável. Os problemas começam com o surgimento eventual de erros. Estas falhas podem ser:

- Cliente não é capaz de localizar o servidor
Neste caso, um dos motivos é o servidor estar fora do ar. Para solucionar pode-se utilizar o mecanismo que faz com que o erro vire uma exceção. Em algumas linguagens é possível escrever procedimentos especiais que são chamados quando da ocorrência de erros específicos, os manipuladores podem ser usados com este propósito.
Mas, infelizmente nem toda linguagem suporta exceções e sinais.

- Perda de mensagens solicitando serviço
Basta fazer com que o kernel inicialize um temporizador quando do envio de uma mensagem de solicitação. Se este expirar antes da chegada de uma resposta ou de uma mensagem de reconhecimento, o kernel deve enviar a mensagem novamente. 

- Perda de mensagens com resposta
Uma solução seria utilizar novamente o recurso do temporizador, mas, neste caso, o kernel do cliente não está seguro a respeito do motivo pelo qual a resposta não chegou. 

- Quedas do servidor
Um método chamado semântica é aguardar até que o servidor dê um novo boot. Um segundo método chamado de semântica de no máximo uma vez, o kernel desiste imediatamente e reporta o problema. Uma terceira alternativa é não garantir absolutamente nada.


- Queda do cliente
Quando um cliente envia uma mensagem de solicitação de trabalho para um servidor, e sai do ar antes que este tenha podido responder, está sendo realizado um processamento órfão. Estes processamentos gastam o tempo do processador e também podem bloquear arquivos ou ocupar recursos escassos. 

ASPECTOS RELATIVOS A IMPLEMENTAÇÃO

O sucesso ou fracasso de um sistema distribuído depende de sua performance, que depende da velocidade de comunicação entre suas partes componentes.

PROTOCOLOS PARA CHAMADA REMOTA A PROCEDIMENTO

A escolha do protocolo deve ser analisada, teoricamente qualquer um vai servir, desde que transporte os bits do kernel do cliente para o do servidor. A primeira decisão diz respeito ao uso de protocolos orientados a conexão ou que não requerem conexão explícita entre as partes comunicantes. 
A segunda questão é sobre o uso de um protocolo padrão ou de um especialmente projetado para sistemas baseados em chamadas remotas a procedimento.
Um último aspecto diz respeito ao tamanho dos pacotes e das mensagens.
CONFIRMAÇÕES

Quando as chamadas tiverem que ser divididas surge a questão de confirmar, ou não, estes individualmente. Uma estratégia conhecida como pare-e-espere faz com que o cliente envie o pacote, e espere por uma confirmação do servidor para enviar o próximo. Outra alternativa conhecida como protocolo em rajadas, o cliente envia todos os pacotes o mais rápido que puder, e o servidor reconhece a mensagem inteira quando todos os pacotes forem recebidos.
Outra técnica conhecida como repetição seletiva o servidor guarda o pacote não danificado em buffer, junto com os anteriores, aguarda que os próximos pacotes cheguem sem problemas, e então solicitar ao cliente a retransmissão apenas o pacote danificado. 

Confirmações 

Quando as chamadas remotas a procedimento tiverem que ser divididas em vários pacotes pequenos, surge uma questão : Os pacotes devem ou não ser confirmados individualmente? Suponha, que um cliente deseja escrever um bloco de dados de 4k em um servidor de arquivo, mas o sistema não pode tratar de pacotes maiores que 1k.Uma estratégia conhecida como protocolo pare-e-espere faz com que o cliente envie o pacote 0,com os primeiros 1k e assim sucessivamente até o último.
Na alternativa conhecida como protocolo de rajadas, o cliente enviar todos os pacotes tão rápido quanto puder, neste caso o servidor reconhece a mensagem inteira, quando todos os pacotes de mensagem forem recebidos.
Quando um pacote chega e o receptor não está preparado vai haver um erro denominado erro por excesso de pacotes e o pacote entrante é perdido.Com o protocolo em rajadas e perfeitamente possível a ocorrência de erros por excesso. Sendo o problema causado pelo fato do chip estar desabilitado temporariamente enquanto processa uma interrupção ,um transmissor esperto pode introduzir um retardo entre o envio de dois pacotes. Se o retardo necessário for pequeno o transmissor pode aguardar em loop de espera ocupada se for grande pode setar um temporizador.

Caminho critico

A seqüência de instruções que é executada a cada chamada remota é denominada caminho crítico. Ele começa quando um cliente chama um stub de cliente, prossegue com o trap para kernel , com a interrupção do lado do servidor, com a ativação do stub para servidor, e finalmente termina no servidor que executa o trabalho solicitado e despacha a resposta através do caminho inverso. 
Schroeder e Burrows (1990) colocaram um pouco de luz na questão ao analisar em detalhes o caminho critico da chamada remota a procedimento implementada na estação de trabalho multiprocessada DEC firefly .
Seus estudos mostram que:
- Para uma chamada nula os custos dominantes dizem a troca de contexto para o stub do servidor, quando o pacote chega a rotina de tratamento da interrupção e ao movimento dos pacotes para a interface da rede a fim de serem transmitidos.
- Para uma chamada remota de 1440 bytes, o quadro muda consideravelmente sendo agora o tempo de transmissão pela ethernet o grande ofensor, e com o tempo de movimentação de pacotes de/para interface de rede vindo logo atrás.

Cópia

A questão das cópias é um aspecto que com freqüência domina os tempos gastos na execução das chamadas remotas. 
Uma característica do hardware que ajuda muito na eliminação de cópias desnecessárias, é chamada scatter-gather. Um chip de interface de rede que pode implementar esta técnica é programado para montar um pacote através da concatenação de dois ou mais buffers.
Em geral a eliminação de cópias é mais fácil de ser realizada do lado da transmissão do que no da recepção. 

GERÊNCIA DO TEMPO

devido ao ruído na comunicação ou ao overflow no buffer de recepção, mensagens podem ser perdidas, em conseqüência, a maioria dos protocolos inicializa um temporizador sempre que uma mensagem e expedida e uma resposta(outra mensagem ou simplesmente um reconhecimento ) e esperada. Se a resposta não chegar em determinado tempo, o temporizador sinaliza, e a mensagem original e retransmitida .
Muitos sistemas mantém uma tabela de processos onde cada entrada possui todas as informações sobre cada um dos processos do sistema. 

Áreas de problemas 

Um  problema muito freqüente é o acesso irrestrito por parte de procedimentos locais e variáveis globais remotas e vice-versa que não pode ser implementado mesmo que a proibição deste tipo de acesso venha a violar o princípio da transparência que diz que os programas não podem agir de forma diferente quando estiverem rodando em sistemas que suportam chamadas remotas a procedimento.
Outro problema diz respeito a linguagem C, por exemplo calculando o produto interno de dois vetores sem especificar o tamanho de tais vetores. O final de cada vetor pode estar amarrado a ocorrência de um determinado valor conhecido apenas pelos procedimentos envolvidos na chamada remota. Sob tais circunstâncias e virtualmente impossível determinar o tamanho dos parâmetros .
A solução para este problema e forçar o programador a definir o tamanho Máximo de todos os parâmetros quando escrever a especificação formal do servidor. 

Introdução a comunicação grupal 

Um grupo é um conjunto de processos que agem juntos, de maneira especificada pelo sistema ou por um usuário. A propriedade fundamental dos grupos é quando uma mensagem é enviada para o grupo, todos os membros deste grupo devem recebê-la.